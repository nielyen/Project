<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"></script>
  <title>test</title>
</head>

<body>
  <div id="app"></div>
</body>
<script type="text/babel">

// 这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。

// 以下是对上述示例发生情况的逐步解释：
// 我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。
// 我们通过指定 ref 为 JSX 属性，将其向下传递给 <FancyButton ref={ref}>。
// React 传递 ref 给 forwardRef 内函数 (props, ref) => ...，作为其第二个参数。
// 我们向下转发该 ref 参数到 <button ref={ref}>，将其指定为 JSX 属性。
// 当 ref 挂载完成，ref.current 将指向 <button> DOM 节点。

  const FancyButton = React.forwardRef((props, ref) => (
    <button ref={ref} className="FancyButton">
      {props.children}
    </button>
  ));

  // 你可以直接获取 DOM button 的 ref：
  const ref = React.createRef();

  class App extends React.Component {
    click = () => {
      console.log(ref.current)
    }

    render(){
      return (
        <div onClick = { this.click }>
          <FancyButton ref={ref} >Click me!</FancyButton>
        </div>
      ) 
    }
  }
  
  ReactDOM.render(
    <App />
    , document.getElementById('app'));
</script>

</html>